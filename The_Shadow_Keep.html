<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Shadow Keep</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Retro Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e5e5e5;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: manipulation;
        }

        /* Custom Scrollbar for Log */
        #game-log::-webkit-scrollbar {
            width: 8px;
        }
        #game-log::-webkit-scrollbar-track {
            background: #2d2d2d; 
        }
        #game-log::-webkit-scrollbar-thumb {
            background: #555; 
            border-radius: 4px;
        }

        /* Grid Animations */
        .cell {
            transition: all 0.1s ease-in-out;
        }
        .player-anim {
            animation: bounce 0.5s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        .damage-text {
            animation: floatUp 0.8s ease-out forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* CRT Effect Overlay */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        
        .btn-press:active {
            transform: translateY(2px);
            background-color: #4b5563;
        }
        
        .spell-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center bg-gray-900 crt text-xs md:text-sm lg:text-base">

    <!-- Game Container (Widened max-w-lg -> max-w-4xl) -->
    <div class="w-full max-w-lg lg:max-w-4xl h-full flex flex-col p-2 md:p-4 gap-2 md:gap-4 relative z-10 justify-center">
        
        <!-- Header / Stats -->
        <div class="bg-gray-800 border-2 border-gray-600 p-3 rounded shadow-lg flex justify-between items-center text-yellow-400">
            <div class="flex flex-col gap-1 w-1/3">
                <span id="player-lvl">LVL: 1</span>
                <span id="player-hp" class="text-red-400">HP: 20/20</span>
                <span id="player-mp" class="text-blue-400">MP: 10/10</span>
            </div>
            <div class="text-center w-1/3">
                <h1 class="text-gray-200 hidden md:block text-base lg:text-xl">THE SHADOW KEEP</h1>
                <span id="floor-display" class="text-gray-500 text-[10px] lg:text-xs">Floor 1</span>
            </div>
            <div class="flex flex-col gap-1 text-right w-1/3">
                <span id="player-xp" class="text-yellow-200">XP: 0/50</span>
                <div class="flex flex-col text-[10px] lg:text-xs">
                    <span id="player-potions" class="text-red-400">‚ù§ Pot: 1</span>
                    <span id="player-mp-potions" class="text-blue-400">üíß Pot: 0</span>
                </div>
            </div>
        </div>

        <!-- Main Viewport Area -->
        <div class="relative flex-grow bg-black border-4 border-gray-700 rounded overflow-hidden shadow-inner">
            
            <!-- Map Layer -->
            <div id="game-grid" class="absolute inset-0 grid place-content-center bg-gray-900">
                <!-- Grid Cells Generated by JS -->
            </div>

            <!-- Combat Overlay -->
            <div id="combat-screen" class="hidden absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center z-20">
                <div class="text-center mb-6 animate-pulse w-full max-w-xs lg:max-w-md">
                    <div id="enemy-sprite" class="text-6xl lg:text-8xl mb-4">üëæ</div>
                    <h2 id="enemy-name" class="text-xl lg:text-3xl text-red-500 mb-2">Goblin</h2>
                    <div class="w-full h-4 lg:h-6 bg-gray-700 border border-gray-500 rounded-full overflow-hidden mx-auto">
                        <div id="enemy-hp-bar" class="h-full bg-red-600 w-full transition-all duration-300"></div>
                    </div>
                    <p id="enemy-hp-text" class="mt-2 text-gray-400 lg:text-lg">HP: 15/15</p>
                </div>

                <!-- Main Combat Menu -->
                <div id="combat-main-menu" class="grid grid-cols-2 gap-4 w-full px-8 max-w-sm lg:max-w-lg">
                    <button onclick="combatAction('attack')" class="btn-press bg-red-900 hover:bg-red-800 border-2 border-red-500 p-4 lg:p-6 rounded text-white shadow lg:text-lg">‚öîÔ∏è Attack</button>
                    <button onclick="showMagicMenu(true)" class="btn-press bg-blue-900 hover:bg-blue-800 border-2 border-blue-500 p-4 lg:p-6 rounded text-white shadow lg:text-lg">‚ú® Magic</button>
                    <button onclick="combatAction('item')" class="btn-press bg-green-900 hover:bg-green-800 border-2 border-green-500 p-4 lg:p-6 rounded text-white shadow lg:text-lg">‚ù§ Heal</button>
                    <button onclick="combatAction('flee')" class="btn-press bg-gray-700 hover:bg-gray-600 border-2 border-gray-400 p-4 lg:p-6 rounded text-gray-300 lg:text-lg">üèÉ Run</button>
                </div>
            </div>

            <!-- Generic Magic Menu (Used for both Combat and Overworld) -->
            <div id="magic-menu" class="hidden absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center z-30 p-4">
                <h3 id="magic-menu-title" class="text-blue-300 text-center mb-4 text-lg lg:text-2xl">Cast Spell</h3>
                <div id="spell-list" class="flex flex-col gap-2 w-full max-w-sm lg:max-w-lg max-h-64 lg:max-h-96 overflow-y-auto mb-4">
                    <!-- Spells injected here -->
                </div>
                <button onclick="hideMagicMenu()" class="btn-press bg-gray-700 border border-gray-500 p-3 lg:p-4 rounded text-white w-32 lg:w-48 lg:text-lg">Cancel</button>
            </div>

            <!-- Level Up Overlay -->
            <div id="level-up-screen" class="hidden absolute inset-0 bg-black bg-opacity-95 flex flex-col items-center justify-center z-50 p-4">
                <h1 class="text-2xl lg:text-4xl text-yellow-400 mb-2 animate-bounce">LEVEL UP!</h1>
                <p class="text-gray-400 mb-6 text-center text-[10px] lg:text-sm">Choose a perk to continue</p>
                <div id="perk-container" class="flex flex-col gap-3 w-full max-w-xs lg:max-w-md">
                    <!-- Perks injected here -->
                </div>
            </div>

            <!-- Game Over Overlay -->
            <div id="game-over-screen" class="hidden absolute inset-0 bg-black flex flex-col items-center justify-center z-50">
                <h1 class="text-4xl lg:text-6xl text-red-600 mb-4">YOU DIED</h1>
                <p id="death-stats" class="text-gray-400 mb-8 text-center px-4 lg:text-xl"></p>
                <button onclick="initGame()" class="bg-white text-black p-4 lg:p-6 border-4 border-gray-500 hover:bg-gray-300 lg:text-xl">TRY AGAIN</button>
            </div>
            
            <!-- Floating Text Container -->
            <div id="floating-text-container" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
        </div>

        <!-- Message Log (Tall on LG screens) -->
        <div id="game-log" class="h-20 lg:h-32 bg-gray-800 border-2 border-gray-600 p-2 overflow-y-auto text-[10px] md:text-xs lg:text-sm font-mono leading-relaxed opacity-90 rounded">
            <div class="text-yellow-500">> Welcome to the Shadow Keep.</div>
            <div class="text-gray-400">> Find the stairs > to descend.</div>
        </div>

        <!-- Controls (Mobile/Desktop) -->
        <div class="flex justify-between items-center h-28 md:h-auto pb-2 px-2 lg:px-8">
            <!-- D-Pad (Scaled Up on LG) -->
            <div class="grid grid-cols-3 gap-1 w-32 h-32 transform scale-75 md:scale-100 lg:scale-125 origin-bottom-left lg:origin-center">
                <div></div>
                <button onclick="movePlayer(0, -1)" class="btn-press bg-gray-700 border-b-4 border-gray-900 rounded active:border-b-0 active:translate-y-1 h-10 flex items-center justify-center text-xl shadow">‚¨ÜÔ∏è</button>
                <div></div>
                <button onclick="movePlayer(-1, 0)" class="btn-press bg-gray-700 border-b-4 border-gray-900 rounded active:border-b-0 active:translate-y-1 h-10 flex items-center justify-center text-xl shadow">‚¨ÖÔ∏è</button>
                <button onclick="movePlayer(0, 1)" class="btn-press bg-gray-700 border-b-4 border-gray-900 rounded active:border-b-0 active:translate-y-1 h-10 flex items-center justify-center text-xl shadow">‚¨áÔ∏è</button>
                <button onclick="movePlayer(1, 0)" class="btn-press bg-gray-700 border-b-4 border-gray-900 rounded active:border-b-0 active:translate-y-1 h-10 flex items-center justify-center text-xl shadow">‚û°Ô∏è</button>
            </div>

            <!-- Action Buttons Grid (Scaled Up on LG) -->
            <div class="grid grid-cols-2 gap-2 transform scale-90 md:scale-100 lg:scale-125 origin-bottom-right lg:origin-center">
                <!-- Magic Button -->
                <button onclick="showMagicMenu(false)" class="col-span-2 btn-press bg-purple-900 border-b-4 border-purple-950 p-2 rounded text-purple-200 active:border-b-0 active:translate-y-1 shadow-lg flex items-center justify-center gap-2 h-10">
                    <span class="text-lg">‚ú®</span>
                    <span class="text-[10px]">MAGIC</span>
                </button>
                
                <!-- HP Potion -->
                <button onclick="usePotion('hp')" class="btn-press bg-red-900 border-b-4 border-red-950 p-2 rounded text-red-200 active:border-b-0 active:translate-y-1 shadow-lg flex flex-col items-center justify-center h-12 w-14">
                    <span class="text-lg">‚ù§</span>
                    <span class="text-[8px]">HP</span>
                </button>

                <!-- MP Potion -->
                <button onclick="usePotion('mp')" class="btn-press bg-blue-900 border-b-4 border-blue-950 p-2 rounded text-blue-200 active:border-b-0 active:translate-y-1 shadow-lg flex flex-col items-center justify-center h-12 w-14">
                    <span class="text-lg">üíß</span>
                    <span class="text-[8px]">MP</span>
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- Game Config & State ---
        const GRID_W = 15;
        const GRID_H = 11;
        
        const TILES = {
            WALL: '#',
            FLOOR: '.',
            PLAYER: '@',
            ENEMY: 'E',
            POTION_HP: 'P_HP',
            POTION_MP: 'P_MP',
            STAIRS: '>',
            BOSS: 'B'
        };

        const ENEMIES = [
            { name: "Slime", symbol: "üíß", hp: 15, maxHp: 15, dmg: 3, xp: 10, color: "text-blue-400" },
            { name: "Bat", symbol: "ü¶á", hp: 10, maxHp: 10, dmg: 2, xp: 8, color: "text-gray-400" },
            { name: "Goblin", symbol: "üë∫", hp: 25, maxHp: 25, dmg: 5, xp: 20, color: "text-green-500" },
            { name: "Orc", symbol: "üëπ", hp: 40, maxHp: 40, dmg: 8, xp: 35, color: "text-red-500" },
            { name: "Wraith", symbol: "üëª", hp: 60, maxHp: 60, dmg: 10, xp: 50, color: "text-purple-300" }
        ];

        const BOSS = { name: "Shadow King", symbol: "üíÄ", hp: 150, maxHp: 150, dmg: 15, xp: 500, color: "text-purple-600" };

        // --- Spell Database ---
        const SPELL_DB = {
            // Starter
            'Magic Missile': { name: 'Magic Missile', cost: 3, dmg: 6, type: 'dmg', target: 'enemy', desc: "Basic magic damage." },
            'Heal': { name: 'Heal', cost: 8, dmg: -15, type: 'heal', target: 'self', desc: "Restores 15 HP." },
            
            // Tier 1
            'Zap': { name: 'Zap', cost: 2, dmg: 4, type: 'dmg', target: 'enemy', desc: "Cheap spark." },
            'Ice Spike': { name: 'Ice Spike', cost: 5, dmg: 8, type: 'dmg', target: 'enemy', desc: "Piercing ice attack." },
            'Wind Shear': { name: 'Wind Shear', cost: 6, dmg: 9, type: 'dmg', target: 'enemy', desc: "Fast air attack." },
            'Rock Smash': { name: 'Rock Smash', cost: 7, dmg: 11, type: 'dmg', target: 'enemy', desc: "Heavy earth dmg." },
            'Dark Pact': { name: 'Dark Pact', cost: 5, dmg: 10, type: 'drain', target: 'enemy', desc: "Quick life drain." },

            // Tier 2
            'Fireball': { name: 'Fireball', cost: 8, dmg: 14, type: 'dmg', target: 'enemy', desc: "High fire damage." },
            'Arcane Blast': { name: 'Arcane Blast', cost: 9, dmg: 16, type: 'dmg', target: 'enemy', desc: "Concentrated magic." },
            'Shadow Bolt': { name: 'Shadow Bolt', cost: 8, dmg: 13, type: 'dmg', target: 'enemy', desc: "Dark energy." },
            'Poison Cloud': { name: 'Poison Cloud', cost: 10, dmg: 15, type: 'dmg', target: 'enemy', desc: "Toxic damage." },
            'Barrier': { name: 'Barrier', cost: 6, dmg: 0, type: 'buff', target: 'self', desc: "+10 Temporary HP." },
            'Drain': { name: 'Drain', cost: 8, dmg: 8, type: 'drain', target: 'enemy', desc: "Steal HP from enemy." },
            
            // Tier 3
            'Vampiric Touch': { name: 'Vampiric Touch', cost: 12, dmg: 12, type: 'drain', target: 'enemy', desc: "Drains life." },
            'Thunderclap': { name: 'Thunderclap', cost: 12, dmg: 20, type: 'dmg', target: 'enemy', desc: "Shocking damage." },
            'Holy Light': { name: 'Holy Light', cost: 15, dmg: -25, type: 'heal', target: 'self', desc: "Restores 25 HP." },
            'Aqua Veil': { name: 'Aqua Veil', cost: 12, dmg: -20, type: 'heal', target: 'self', desc: "Water healing." },
            'Stone Skin': { name: 'Stone Skin', cost: 12, dmg: 0, type: 'buff', target: 'self', desc: "+20 Temporary HP." },
            
            // Tier 4 (Special)
            'Teleport': { name: 'Teleport', cost: 10, dmg: 0, type: 'utility', target: 'self', desc: "Move to random spot." },
            'Frost Nova': { name: 'Frost Nova', cost: 15, dmg: 8, type: 'stun', target: 'enemy', desc: "Freeze enemy (Skip Turn)." },
            'Smite': { name: 'Smite', cost: 18, dmg: 35, type: 'dmg', target: 'enemy', desc: "Holy damage." },
            'Solar Flare': { name: 'Solar Flare', cost: 18, dmg: 30, type: 'dmg', target: 'enemy', desc: "Blinding light." },
            
            // Tier 5 (Ultimate)
            'Inferno': { name: 'Inferno', cost: 20, dmg: 40, type: 'dmg', target: 'enemy', desc: "Massive fire damage." },
            'Divine Shield': { name: 'Divine Shield', cost: 25, dmg: 0, type: 'buff', target: 'self', desc: "+40 Temporary HP." },
            'Regrowth': { name: 'Regrowth', cost: 20, dmg: -40, type: 'heal', target: 'self', desc: "Major healing." },
            'Time Stop': { name: 'Time Stop', cost: 30, dmg: 0, type: 'stun', target: 'enemy', desc: "Skips enemy turn." },
            'Meteor': { name: 'Meteor', cost: 35, dmg: 60, type: 'dmg', target: 'enemy', desc: "Ultimate destruction." },
            'Greater Heal': { name: 'Greater Heal', cost: 30, dmg: -60, type: 'heal', target: 'self', desc: "Massive recovery." }
        };

        let gameState = {
            map: [],
            player: { 
                x: 1, y: 1, 
                hp: 30, maxHp: 30, 
                mp: 10, maxMp: 10,
                level: 1, xp: 0, nextLevel: 50, 
                potions: 2, mpPotions: 1,
                dmg: 5,
                spells: ['Magic Missile']
            },
            enemies: [],
            items: [],
            floor: 1,
            inCombat: false,
            currentEnemy: null,
            paused: false
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'step') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.05);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'magic') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'pickup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(1000, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'levelUp') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.setValueAtTime(400, now + 0.1);
                osc.frequency.setValueAtTime(600, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            }
        }

        // --- Initialization ---
        function initGame() {
            gameState.player = { 
                x: 1, y: 1, 
                hp: 30, maxHp: 30, 
                mp: 10, maxMp: 10,
                level: 1, xp: 0, nextLevel: 50, 
                potions: 2, mpPotions: 1,
                dmg: 4,
                spells: ['Magic Missile', 'Heal']
            };
            gameState.floor = 1;
            gameState.inCombat = false;
            gameState.paused = false;
            
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('level-up-screen').classList.add('hidden');
            generateFloor();
            updateUI();
            renderMap();
            log("Welcome to the dungeon.");
        }

        function generateFloor() {
            const width = 40;
            const height = 40;
            gameState.map = Array(height).fill(null).map(() => Array(width).fill(TILES.WALL));
            gameState.enemies = [];
            gameState.items = [];

            let x = Math.floor(width / 2);
            let y = Math.floor(height / 2);
            gameState.player.x = x;
            gameState.player.y = y;
            
            let floors = 0;
            const targetFloors = 300 + (gameState.floor * 10);

            while (floors < targetFloors) {
                if (gameState.map[y][x] === TILES.WALL) {
                    gameState.map[y][x] = TILES.FLOOR;
                    floors++;
                }
                const dir = Math.floor(Math.random() * 4);
                if (dir === 0 && y > 1) y--;
                else if (dir === 1 && y < height - 2) y++;
                else if (dir === 2 && x > 1) x--;
                else if (dir === 3 && x < width - 2) x++;
            }

            // Populate
            for(let r=0; r<height; r++) {
                for(let c=0; c<width; c++) {
                    if(gameState.map[r][c] === TILES.FLOOR) {
                        if(r === gameState.player.y && c === gameState.player.x) continue;

                        const roll = Math.random();
                        if (roll < 0.03 + (gameState.floor * 0.005)) {
                            // Enemy
                            const enemyTemplate = gameState.floor % 5 === 0 && roll < 0.005 ? BOSS : ENEMIES[Math.min(Math.floor(Math.random() * (gameState.floor + 1)), ENEMIES.length - 1)];
                            gameState.enemies.push({ ...enemyTemplate, x: c, y: r, currentHp: enemyTemplate.maxHp });
                        } else if (roll < 0.05) {
                            // Potion
                            if (Math.random() < 0.7) {
                                gameState.items.push({ x: c, y: r, type: 'hp_potion' });
                            } else {
                                gameState.items.push({ x: c, y: r, type: 'mp_potion' });
                            }
                        }
                    }
                }
            }

            let stairPlaced = false;
            while(!stairPlaced) {
                let rx = Math.floor(Math.random() * width);
                let ry = Math.floor(Math.random() * height);
                if(gameState.map[ry][rx] === TILES.FLOOR) {
                    const dist = Math.abs(rx - gameState.player.x) + Math.abs(ry - gameState.player.y);
                    if(dist > 15) {
                        gameState.items.push({ x: rx, y: ry, type: 'stairs' });
                        stairPlaced = true;
                    }
                }
            }
        }

        // --- Core Movement ---
        function movePlayer(dx, dy) {
            if (gameState.inCombat || gameState.paused) return;

            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;

            if (gameState.map[newY][newX] === TILES.WALL) return;

            const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                startCombat(enemy);
                return;
            }

            gameState.player.x = newX;
            gameState.player.y = newY;
            playSound('step');

            // Pickups
            const itemIndex = gameState.items.findIndex(i => i.x === newX && i.y === newY);
            if (itemIndex !== -1) {
                const item = gameState.items[itemIndex];
                if (item.type === 'hp_potion') {
                    gameState.player.potions++;
                    log("Found Health Potion!", "text-red-400");
                    playSound('pickup');
                    gameState.items.splice(itemIndex, 1);
                } else if (item.type === 'mp_potion') {
                    gameState.player.mpPotions++;
                    log("Found Mana Potion!", "text-blue-400");
                    playSound('pickup');
                    gameState.items.splice(itemIndex, 1);
                } else if (item.type === 'stairs') {
                    nextFloor();
                    return;
                }
                updateUI();
            }

            renderMap();
        }

        function nextFloor() {
            gameState.floor++;
            gameState.player.mp = Math.min(gameState.player.maxMp, gameState.player.mp + 2);
            log(`Floor ${gameState.floor}. MP restored slightly.`, "text-yellow-400");
            generateFloor();
            updateUI();
            renderMap();
        }

        // --- Level Up System ---
        function checkLevelUp() {
            if (gameState.player.xp >= gameState.player.nextLevel) {
                gameState.player.xp -= gameState.player.nextLevel;
                gameState.player.nextLevel = Math.floor(gameState.player.nextLevel * 1.6);
                triggerLevelUp();
            }
        }

        function triggerLevelUp() {
            gameState.paused = true;
            gameState.player.level++;
            playSound('levelUp');
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mp = gameState.player.maxMp;
            
            const screen = document.getElementById('level-up-screen');
            const container = document.getElementById('perk-container');
            container.innerHTML = '';
            
            const perks = [];
            
            // Standard Stat Upgrades
            perks.push({ id: 'might', name: 'üí™ Might (+2 DMG)', action: () => { gameState.player.dmg += 2; } });
            perks.push({ id: 'vit', name: '‚ù§Ô∏è Vitality (+10 Max HP)', action: () => { gameState.player.maxHp += 10; gameState.player.hp += 10; } });
            perks.push({ id: 'wis', name: 'üß† Wisdom (+5 Max MP)', action: () => { gameState.player.maxMp += 5; gameState.player.mp += 5; } });
            
            // Find learnable spells
            const unknownSpells = Object.values(SPELL_DB).filter(s => !gameState.player.spells.includes(s.name));
            
            // Try to add up to 2 random spells to the pool
            if (unknownSpells.length > 0) {
                // Shuffle unknown spells
                unknownSpells.sort(() => 0.5 - Math.random());
                
                // Add first spell
                const spell1 = unknownSpells[0];
                perks.push({ 
                    id: 'spell1', 
                    name: `üìú Learn ${spell1.name}`, 
                    action: () => { 
                        gameState.player.spells.push(spell1.name); 
                        log(`Learned ${spell1.name}!`, "text-purple-400");
                    } 
                });

                // Add second spell if available
                if (unknownSpells.length > 1) {
                     const spell2 = unknownSpells[1];
                     perks.push({ 
                        id: 'spell2', 
                        name: `üìú Learn ${spell2.name}`, 
                        action: () => { 
                            gameState.player.spells.push(spell2.name); 
                            log(`Learned ${spell2.name}!`, "text-purple-400");
                        } 
                    });
                }
            }

            // Shuffle perks to mix stats and spells
            perks.sort(() => 0.5 - Math.random());
            
            // Pick top 3 (or 4 to give more choice now that we have many spells)
            // Let's stick to 3 but ensure at least one spell is there if possible by weighting logic above, 
            // or just simple shuffle which is fair.
            const choices = perks.slice(0, 3);

            choices.forEach(perk => {
                const btn = document.createElement('button');
                btn.className = "bg-gray-700 hover:bg-gray-600 border border-gray-400 p-3 rounded text-left text-white shadow-lg btn-press lg:text-lg";
                btn.innerText = perk.name;
                btn.onclick = () => {
                    perk.action();
                    log(`Level ${gameState.player.level} reached!`, "text-yellow-400");
                    screen.classList.add('hidden');
                    gameState.paused = false;
                    updateUI();
                    checkLevelUp(); 
                };
                container.appendChild(btn);
            });

            screen.classList.remove('hidden');
        }

        // --- Magic & Combat Logic ---

        function showMagicMenu(isCombat) {
            if (gameState.paused && !gameState.inCombat) return;

            const menu = document.getElementById('magic-menu');
            const list = document.getElementById('spell-list');
            const title = document.getElementById('magic-menu-title');
            
            list.innerHTML = '';
            menu.classList.remove('hidden');
            
            if (isCombat) document.getElementById('combat-main-menu').classList.add('hidden');

            title.innerText = isCombat ? "Combat Spells" : "Overworld Magic";

            gameState.player.spells.forEach(spellName => {
                const spell = SPELL_DB[spellName];
                
                if (isCombat && spell.target === 'utility') return;
                if (!isCombat && (spell.target === 'enemy' || spell.type === 'stun')) return;

                const btn = document.createElement('button');
                const canCast = gameState.player.mp >= spell.cost;
                
                btn.className = `spell-btn p-2 rounded text-left flex justify-between items-center ${canCast ? 'bg-blue-900 hover:bg-blue-800 text-white' : 'bg-gray-800 text-gray-500'}`;
                btn.disabled = !canCast;
                btn.innerHTML = `
                    <div class="flex flex-col">
                        <span class="lg:text-lg">${spell.name}</span>
                        <span class="text-[8px] lg:text-xs text-gray-300">${spell.desc}</span>
                    </div> 
                    <span class="text-[10px] lg:text-sm">${spell.cost}MP</span>
                `;
                
                btn.onclick = () => {
                    castSpell(spell, isCombat);
                    if (!isCombat) hideMagicMenu(); 
                };
                list.appendChild(btn);
            });
            
            if (list.children.length === 0) {
                list.innerHTML = `<div class="text-gray-500 text-center italic lg:text-lg">No spells available.</div>`;
            }
        }

        function hideMagicMenu() {
            document.getElementById('magic-menu').classList.add('hidden');
            if (gameState.inCombat) {
                document.getElementById('combat-main-menu').classList.remove('hidden');
            }
        }

        function castSpell(spell, isCombat) {
            const player = gameState.player;
            const enemy = gameState.currentEnemy;
            let skipEnemyTurn = false;
            
            player.mp -= spell.cost;
            playSound('magic');
            
            // Logic
            let dmg = 0;
            if (spell.type === 'dmg' || spell.type === 'stun') {
                dmg = spell.dmg + Math.floor(player.level / 2);
                if(isCombat && enemy) {
                    enemy.currentHp -= dmg;
                    log(`Casted ${spell.name}! ${dmg} damage.`, "text-blue-300");
                    spawnFloatingText(dmg, 'cyan');
                    
                    if(spell.type === 'stun') {
                        skipEnemyTurn = true;
                        log(`${enemy.name} is stunned!`, "text-blue-200");
                    }
                }
            } else if (spell.type === 'heal') {
                const healAmt = Math.abs(spell.dmg) + player.level;
                player.hp = Math.min(player.maxHp, player.hp + healAmt);
                log(`Casted ${spell.name}! +${healAmt} HP.`, "text-green-300");
                spawnFloatingText('+' + healAmt, 'green');
            } else if (spell.type === 'drain') {
                dmg = spell.dmg + Math.floor(player.level / 2);
                if(isCombat && enemy) {
                    enemy.currentHp -= dmg;
                    player.hp = Math.min(player.maxHp, player.hp + dmg);
                    log(`Drained ${dmg} life!`, "text-purple-400");
                    spawnFloatingText(dmg, 'purple');
                }
            } else if (spell.type === 'buff') {
                // Barrier effect - simple temp HP add
                // To keep it simple, we just add to current HP, potentially exceeding max for this turn, or just cap at max + buff
                // For simplicity in this engine, we treat it as a heal that can't be healed normally? 
                // Let's just treat it as a Heal that creates "Overheal" or just standard heal + buffer.
                // Re-reading original simple implementation: player.hp += 10.
                // Let's refine: add to HP, allow exceeding MaxHP temporarily? 
                // The UI displays HP/MaxHP, so exceeding looks cool.
                player.hp += 10; // Fixed amount for Barrier, could scale
                if (spell.name === 'Stone Skin') player.hp += 10;
                if (spell.name === 'Divine Shield') player.hp += 30;
                
                log(`${spell.name} active! HP boosted.`, "text-blue-200");
                spawnFloatingText('Buff', 'blue');
            } else if (spell.type === 'utility') {
                if (!isCombat) {
                    let moved = false;
                    let attempts = 0;
                    while(!moved && attempts < 100) {
                        let rx = Math.floor(Math.random() * 40);
                        let ry = Math.floor(Math.random() * 40);
                        if(gameState.map[ry] && gameState.map[ry][rx] === TILES.FLOOR && !gameState.enemies.some(e=>e.x===rx && e.y===ry)) {
                            player.x = rx;
                            player.y = ry;
                            moved = true;
                            log("Teleported!", "text-purple-500");
                            renderMap();
                        }
                        attempts++;
                    }
                }
            }

            updateUI();

            if (isCombat) {
                hideMagicMenu();
                checkEnemyDeath(enemy, skipEnemyTurn);
            }
        }

        // --- Combat Flow ---
        function startCombat(enemy) {
            gameState.inCombat = true;
            gameState.currentEnemy = enemy;
            
            document.getElementById('combat-screen').classList.remove('hidden');
            document.getElementById('combat-main-menu').classList.remove('hidden');
            document.getElementById('magic-menu').classList.add('hidden');
            
            document.getElementById('enemy-sprite').innerText = enemy.symbol;
            document.getElementById('enemy-name').innerText = enemy.name;
            updateCombatUI();
            log(`Encountered a ${enemy.name}!`, "text-red-400");
        }

        function combatAction(action) {
            if (gameState.paused) return;
            
            const enemy = gameState.currentEnemy;
            const player = gameState.player;
            let turnPassed = true;

            if (action === 'attack') {
                const dmg = Math.max(1, Math.floor(player.dmg + (Math.random() * 2)));
                enemy.currentHp -= dmg;
                log(`Attacked ${enemy.name} for ${dmg}.`);
                spawnFloatingText(dmg, 'white');
                playSound('hit');
            } 
            else if (action === 'item') {
                if (player.potions > 0) {
                    const heal = Math.floor(player.maxHp * 0.4) + 5;
                    player.hp = Math.min(player.hp + heal, player.maxHp);
                    player.potions--;
                    log(`Used potion. +${heal} HP.`, "text-green-400");
                    updateUI();
                } else {
                    log("No HP potions!", "text-red-500");
                    turnPassed = false;
                }
            } 
            else if (action === 'flee') {
                if (Math.random() > 0.4) {
                    log("You fled safely.");
                    gameState.inCombat = false;
                    document.getElementById('combat-screen').classList.add('hidden');
                    return;
                } else {
                    log("Failed to flee!", "text-red-500");
                }
            }

            if (turnPassed) checkEnemyDeath(enemy, false);
        }

        function checkEnemyDeath(enemy, skipTurn) {
            if (enemy.currentHp <= 0) {
                endCombat(true);
            } else {
                if(!skipTurn) {
                    enemyTurn();
                } else {
                    updateCombatUI(); // Just update bars if stunned
                }
            }
        }

        function enemyTurn() {
            setTimeout(() => {
                if (!gameState.inCombat) return;

                const enemy = gameState.currentEnemy;
                const player = gameState.player;
                
                const enemyDmg = Math.max(0, Math.floor(enemy.dmg - (Math.random())));
                player.hp -= enemyDmg;
                log(`${enemy.name} attacks! -${enemyDmg} HP`, "text-red-300");
                updateUI();
                
                const shake = document.body;
                shake.style.transform = `translate(${Math.random()*4-2}px, ${Math.random()*4-2}px)`;
                setTimeout(() => shake.style.transform = 'none', 100);

                if (player.hp <= 0) {
                    gameOver();
                }
                updateCombatUI();
            }, 600);
        }

        function endCombat(victory) {
            const enemy = gameState.currentEnemy;
            document.getElementById('combat-screen').classList.add('hidden');
            gameState.inCombat = false;
            
            if (victory) {
                const idx = gameState.enemies.indexOf(enemy);
                if (idx > -1) gameState.enemies.splice(idx, 1);
                
                log(`Victory! +${enemy.xp} XP.`, "text-yellow-300");
                gameState.player.xp += enemy.xp;

                if(Math.random() < 0.25) {
                    if (Math.random() > 0.5) {
                        gameState.player.potions++;
                        log("Found a HP potion.", "text-green-400");
                    } else {
                        gameState.player.mpPotions++;
                        log("Found a Mana potion.", "text-blue-400");
                    }
                }
                
                updateUI();
                renderMap();
                checkLevelUp();
            }
        }

        function usePotion(type) {
            if (gameState.inCombat) return; 
            
            if (type === 'hp') {
                if (gameState.player.potions > 0) {
                    const heal = Math.floor(gameState.player.maxHp * 0.4) + 5;
                    gameState.player.hp = Math.min(gameState.player.hp + heal, gameState.player.maxHp);
                    gameState.player.potions--;
                    log(`HP Potion: +${heal} HP.`, "text-green-400");
                } else {
                    log("No HP Potions!", "text-gray-500");
                }
            } else if (type === 'mp') {
                if (gameState.player.mpPotions > 0) {
                    const restore = 10 + Math.floor(gameState.player.level * 2);
                    gameState.player.mp = Math.min(gameState.player.mp + restore, gameState.player.maxMp);
                    gameState.player.mpPotions--;
                    log(`Mana Potion: +${restore} MP.`, "text-blue-400");
                } else {
                    log("No Mana Potions!", "text-gray-500");
                }
            }
            updateUI();
        }

        function gameOver() {
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('death-stats').innerText = `Floor: ${gameState.floor} | Level: ${gameState.player.level}`;
        }

        // --- Rendering ---
        function renderMap() {
            const gridEl = document.getElementById('game-grid');
            gridEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${GRID_W}, 1fr)`;
            gridEl.style.gridTemplateRows = `repeat(${GRID_H}, 1fr)`;
            
            const startX = gameState.player.x - Math.floor(GRID_W / 2);
            const startY = gameState.player.y - Math.floor(GRID_H / 2);

            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const mapX = startX + x;
                    const mapY = startY + y;
                    const cell = document.createElement('div');
                    // Responsive sizing: Default w-6, md:w-8, lg:w-12
                    cell.className = 'w-6 h-6 md:w-8 md:h-8 lg:w-12 lg:h-12 flex items-center justify-center text-lg md:text-xl lg:text-3xl cell';

                    if (mapY >= 0 && mapY < gameState.map.length && mapX >= 0 && mapX < gameState.map[0].length) {
                        const tile = gameState.map[mapY][mapX];
                        const enemy = gameState.enemies.find(e => e.x === mapX && e.y === mapY);
                        const item = gameState.items.find(i => i.x === mapX && i.y === mapY);

                        if (gameState.player.x === mapX && gameState.player.y === mapY) {
                            cell.innerHTML = '<span class="player-anim">üßô‚Äç‚ôÇÔ∏è</span>';
                        } else if (enemy) {
                            cell.innerHTML = enemy.symbol;
                            cell.className += ` ${enemy.color} animate-pulse`;
                        } else if (item) {
                            if (item.type === 'hp_potion') cell.innerHTML = '<span class="text-red-500">üß™</span>';
                            else if (item.type === 'mp_potion') cell.innerHTML = '<span class="text-blue-500">üß™</span>';
                            else cell.innerHTML = 'üö™';
                        } else {
                            if (tile === TILES.WALL) cell.style.backgroundColor = '#333';
                            else cell.innerHTML = '<span class="text-gray-800 text-xs lg:text-sm">.</span>';
                        }
                    } else {
                        cell.style.backgroundColor = '#000';
                    }
                    gridEl.appendChild(cell);
                }
            }
        }

        function updateUI() {
            document.getElementById('player-hp').innerText = `HP: ${gameState.player.hp}/${gameState.player.maxHp}`;
            document.getElementById('player-mp').innerText = `MP: ${gameState.player.mp}/${gameState.player.maxMp}`;
            document.getElementById('player-lvl').innerText = `LVL: ${gameState.player.level}`;
            document.getElementById('player-xp').innerText = `XP: ${gameState.player.xp}/${gameState.player.nextLevel}`;
            document.getElementById('player-potions').innerText = `‚ù§ Pot: ${gameState.player.potions}`;
            document.getElementById('player-mp-potions').innerText = `üíß Pot: ${gameState.player.mpPotions}`;
            document.getElementById('floor-display').innerText = `Floor ${gameState.floor}`;
        }

        function updateCombatUI() {
            const enemy = gameState.currentEnemy;
            const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
            document.getElementById('enemy-hp-bar').style.width = `${hpPercent}%`;
            document.getElementById('enemy-hp-text').innerText = `HP: ${enemy.currentHp}/${enemy.maxHp}`;
        }

        function log(msg, classes = "text-gray-300") {
            const logEl = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = `${classes} mb-1`;
            entry.innerText = `> ${msg}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function spawnFloatingText(text, color) {
            const container = document.getElementById('floating-text-container');
            const el = document.createElement('div');
            el.innerText = `${text}`;
            el.className = `absolute text-xl lg:text-3xl font-bold damage-text ${color === 'white' ? 'text-white' : color === 'cyan' ? 'text-cyan-400' : color === 'green' ? 'text-green-400' : 'text-purple-400'}`;
            el.style.left = '50%';
            el.style.top = '45%';
            container.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'w', 'W'].includes(e.key)) movePlayer(0, -1);
            if (['ArrowDown', 's', 'S'].includes(e.key)) movePlayer(0, 1);
            if (['ArrowLeft', 'a', 'A'].includes(e.key)) movePlayer(-1, 0);
            if (['ArrowRight', 'd', 'D'].includes(e.key)) movePlayer(1, 0);
        });

        initGame();
    </script>
</body>
</html>
